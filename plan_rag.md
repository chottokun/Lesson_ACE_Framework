# 外部データベースをRAGとして統合する実装案レポート

## 1. 現状のアーキテクチャ分析
ACE Frameworkの現在のRAG（検索拡張生成）実装は、`ACE_Memory`クラスがSQLite（構造化データおよび全文検索 FTS5）とFAISS（ベクトル検索）を管理するハイブリッド構成となっています。

### 主要な構成要素と役割
- **ACE_Memory (`src/ace_rm/memory/core.py`)**: ローカル長期記憶（LTM）の核心部。データの追加・検索・更新を担います。
- **Curator (`src/ace_rm/agent/graph.py`)**: ユーザーの意図を分析し、検索クエリを生成します。LTMから関連情報を取得し、エージェントのコンテキストに注入します。
- **Background Worker (`src/ace_rm/workers/background.py`)**: 対話から新しい知識を抽出し、LTMを更新する非同期プロセス。

## 2. 外部データベース統合の必要性
現在の実装は「エージェント自身の経験」を蓄積することに特化していますが、実用的なアプリケーションでは、既存の社内ドキュメント、技術マニュアル、リアルタイムAPIなどの「外部知識」を活用することが求められます。

## 3. 実装の可能性とアプローチ案

### 案A: `ACE_Memory` クラスのマルチソース化（統合検索型）
`ACE_Memory.search` メソッドの内部で、ローカルメモリと並行して外部データベースを検索し、結果をマージするアプローチです。

- **実装の詳細**:
    - `ACE_Memory` に `ExternalRetriever` などのプラグイン機構を導入。
    - 検索時に `asyncio.gather` を用いて、ローカルと外部を並列検索。
    - スコアリングを正規化し、上位K件の結果を統合。
- **メリット**: 既存の `Curator` や `Agent` のロジックを変更せずに、検索範囲のみを拡張できる。
- **デメリット**: 外部ソースの応答速度が全体のレスポンスに直結する。

### 案B: Curatorによるインテリジェント・ルーティング（選択検索型）
`Curator` ノードが、ユーザーの問いに対して「ローカルメモリ」「外部技術DB」「一般知識」のどこを検索すべきかをLLMで判断するアプローチです。

- **実装の詳細**:
    - `INTENT_ANALYSIS_PROMPT` に検索ソース選択の指示を追加。
    - 抽出された `search_source` に基づいて、適切な検索エンジンを呼び出す。
- **メリット**: 不要な検索を抑制でき、コストとレイテンシの最適化が可能。
- **デメリット**: 判断のためのLLM処理が増え、プロンプトの設計難易度が上がる。

### 案C: ツールとしての外部検索提供（Agent-driven型）
外部データベース検索を「ツール」として定義し、エージェント（LLM）が必要だと判断した時のみ自律的に実行させるアプローチです。

- **実装の詳細**:
    - LangChainの `@tool` デコレータを使用して外部検索機能を実装。
    - エージェントの `tools` リストに追加。
- **メリット**: 多段階の検索（1回目の検索結果を見てから別のクエリで再検索など）が可能。
- **デメリット**: エージェントがツールの使用を忘れる可能性（ハルシネーション）がある。

## 4. 技術的課題と対策
- **レイテンシ管理**: 外部APIの呼び出しには厳格なタイムアウトを設定し、失敗時にはローカルメモリのみで継続するフォールバック処理が必要。
- **データの整合性**: 外部DBのチャンクサイズや重複判定の基準をACE Frameworkの `BackgroundWorker` と整合させる必要がある。
- **セキュリティ**: APIキーの管理や、外部DBへのアクセス権限（RLSなど）の考慮。

## 5. 推奨される実装ロードマップ
1. **インターフェースの抽象化**:
   `BaseRetriever` クラスを定義し、ローカルLTMも一つのリトリーバーとして扱うように `src/ace_rm/memory/core.py` をリファクタリング。
2. **外部コネクタの実装**:
   Elasticsearch, Pinecone, またはシンプルなREST API経由のドキュメント検索用コネクタを作成。
3. **ハイブリッド検索エンジンの構築**:
   案Aをベースに、複数リトリーバーの結果を統合する `MultiRetriever` クラスを実装。
4. **UIへの統合**:
   `app.py` のデバッグパネルに、検索対象とする外部DBの選択スイッチを追加。

## 6. 結論
ACE Frameworkの現在のモジュール化された構造（`ACE_Memory` と `Curator` の分離）は、外部RAGの統合に対して非常に高い適性を持っています。まずは案Aによる統合検索から着手し、将来的に案Bのルーティングを組み合わせることで、精度の高い知識補完システムの構築が可能です。
