# 外部データベースをRAGとして統合する実装案レポート

## 1. 現状のアーキテクチャ分析
ACE Frameworkの現在のRAG（検索拡張生成）実装は、`ACE_Memory`クラスがSQLite（構造化データおよび全文検索 FTS5）とFAISS（ベクトル検索）を管理するハイブリッド構成となっています。

### 主要な構成要素と役割
- **ACE_Memory (`src/ace_rm/memory/core.py`)**: ローカル長期記憶（LTM）の核心部。データの追加・検索・更新を担います。
- **Curator (`src/ace_rm/agent/graph.py`)**: ユーザーの意図を分析し、検索クエリを生成します。LTMから関連情報を取得し、エージェントのコンテキストに注入します。
- **Background Worker (`src/ace_rm/workers/background.py`)**: 対話から新しい知識を抽出し、LTMを更新する非同期プロセス。

## 2. 外部データベース統合の必要性
現在の実装は「エージェント自身の経験」を蓄積することに特化していますが、実用的なアプリケーションでは、既存の社内ドキュメント、技術マニュアル、リアルタイムAPIなどの「外部知識」を活用することが求められます。

## 3. 実装の可能性とアプローチ案

### 案A: `ACE_Memory` クラスのマルチソース化（統合検索型）
`ACE_Memory.search` メソッドの内部で、ローカルメモリと並行して外部データベースを検索し、結果をマージするアプローチです。

- **実装の詳細**:
    - `ACE_Memory` に `ExternalRetriever` などのプラグイン機構を導入。
    - 検索時に `asyncio.gather` を用いて、ローカルと外部を並列検索。
    - スコアリングを正規化し、上位K件の結果を統合。
- **メリット**: 既存の `Curator` や `Agent` のロジックを変更せずに、検索範囲のみを拡張できる。
- **デメリット**: 外部ソースの応答速度が全体のレスポンスに直結する。

### 案B: Curatorによるインテリジェント・ルーティング（選択検索型）
`Curator` ノードが、ユーザーの問いに対して「ローカルメモリ」「外部技術DB」「一般知識」のどこを検索すべきかをLLMで判断するアプローチです。

- **実装の詳細**:
    - `INTENT_ANALYSIS_PROMPT` に検索ソース選択の指示を追加。
    - 抽出された `search_source` に基づいて、適切な検索エンジンを呼び出す。
- **メリット**: 不要な検索を抑制でき、コストとレイテンシの最適化が可能。
- **デメリット**: 判断のためのLLM処理が増え、プロンプトの設計難易度が上がる。

### 案C: ツールとしての外部検索提供（Agent-driven型）
外部データベース検索を「ツール」として定義し、エージェント（LLM）が必要だと判断した時のみ自律的に実行させるアプローチです。

- **実装の詳細**:
    - LangChainの `@tool` デコレータを使用して外部検索機能を実装。
    - エージェントの `tools` リストに追加。
- **メリット**: 多段階の検索（1回目の検索結果を見てから別のクエリで再検索など）が可能。
- **デメリット**: エージェントがツールの使用を忘れる可能性（ハルシネーション）がある。

### 案D: LTM基盤のChromaDBへの全面移行（リプレース型）
現在の「SQLite + FAISS」による二重管理を廃止し、長期記憶（LTM）の基盤そのものをChromaDBへ統合するアプローチです。

- **実装の詳細**:
    - `ACE_Memory` クラスをリファクタリングし、バックエンドを ChromaDB に置換。
    - ドキュメント、メタデータ（`entities`, `problem_class`）、ベクトルを一括管理。
    - `TaskQueue` は状態管理（`pending`/`done`等）の特性上、引き続きSQLiteで運用するのが最適。
- **メリット**:
    - **アーキテクチャの簡素化**: FAISSのインデックスファイル管理や `FileLock` による排他制御が不要になり、コードの堅牢性が向上。
    - **アトミックな更新**: ドキュメントとベクトルの更新が単一のDB操作で完結。
- **デメリット**:
    - **全文検索の制約**: SQLite FTS5ほどの高度なキーワード検索（BM25ランキングや複雑なクエリ演算子）が標準では制限される可能性がある。

## 4. ローカルChromaDBの外部RAGとしての活用
既存のローカルLTM（SQLite+FAISS）とは別に、既存のナレッジベースとしてChromaDBを運用している場合、これを「外部RAG」の一種としてACE Frameworkに接続することが可能です。

### 実装のアプローチ
- **ChromaDBリトリーバーの作成**:
  `chromadb` クライアントを使用し、特定のコレクションからベクトル検索を行う専用クラスを実装します。
- **ハイブリッド検索への組み込み**:
  `ACE_Memory.search` の中で、自身のFAISS検索結果とChromaDBからの検索結果を統合します。
- **メタデータ・フィルタリングの活用**:
  ChromaDBのメタデータ機能を活用し、Curatorが抽出した `problem_class` や `entities` に基づいて、特定のカテゴリのドキュメントのみを検索範囲に含める最適化が可能です。

### 利点
- **永続性とスケーラビリティ**: FAISSのインメモリ管理（またはファイルベース管理）に比べ、ChromaDBは本格的なDBとしての管理機能（コレクション管理、永続化の堅牢性）に優れています。
- **既存資産の活用**: すでに別のプロジェクトで構築されたベクトルDBを、ACE Frameworkから再利用できます。

## 5. 技術的課題と対策
- **レイテンシ管理**: 外部APIや別プロセスのDB呼び出しには厳格なタイムアウトを設定し、失敗時にはローカルメモリのみで継続するフォールバック処理が必要。
- **データの整合性**: 外部DBのチャンクサイズや重複判定の基準をACE Frameworkの `BackgroundWorker` と整合させる必要がある。
- **セキュリティ**: APIキーの管理や、外部DBへのアクセス権限（RLSなど）の考慮。

## 6. 推奨される実装ロードマップ
1. **インターフェースの抽象化**:
   `BaseRetriever` クラスを定義し、ローカルLTMも一つのリトリーバーとして扱うように `src/ace_rm/memory/core.py` をリファクタリング。
2. **外部コネクタの実装**:
   ChromaDB, Elasticsearch, Pinecone, またはシンプルなREST API経由のドキュメント検索用コネクタを作成。
3. **ハイブリッド検索エンジンの構築**:
   案Aをベースに、複数リトリーバーの結果を統合する `MultiRetriever` クラスを実装。
4. **UIへの統合**:
   `app.py` のデバッグパネルに、検索対象とする外部DBの選択スイッチを追加。

## 7. 結論
ACE Frameworkの現在のモジュール化された構造（`ACE_Memory` と `Curator` の分離）は、ChromaDBへの全面移行（案D）および外部RAGとしての統合（案A/B）の両方に対して高い適性を持っています。

- **メンテナンス性重視**なら、案D（ChromaDBへの一本化）を推奨。
- **既存ナレッジの活用重視**なら、案A（統合検索）を推奨。

まずはインターフェースの抽象化を行い、バックエンドを容易に切り替えられる構成にすることで、柔軟なシステム進化が可能になります。
